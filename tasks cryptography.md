Эти задачи использовались на двух хакатонах (<названия хакатонов>). Цель – взломать смарт-контракт. Для решения задачи первым делом надо было обратить внимание на то, что несмотря на то, что в коде смарт-контракта используется стандартный алгоритм ECDSA – международный стандарт электронной подписи, параметры кривой выглядят подозрительно – они кроме как в этом смарт-контракте никогда и никем не использовались. (Ну, само по себе это конечно еще ничего не означает – ведь сгенерировать вполне пригодную для использования эллиптическую не так уж сложно – для этого нужно знать всего несколько правил о том, как не прострелить себе ногу. Тот, кто их не знает скорее всего сгенерирует “слабую” кривую, т.е. такую кривую, для которой можно решить ECDLP (Elliptic Discrete Curve Logarithm Problem) и, как следствие, злоумышленник, зная открытый ключ, сможет вычислить соответствующий закрытый ключ. 
В трех роликах мы расскажем вам про три основные криптографические атаки, которые может попытаться предпринять злоумышленник, чтобы “взломать” кривую. Оказывается, что “на глазок” оценить, что кривая “слабая” – во всех трех случаях элементарно.  Итак, первый случай – число точек кривой не простое, а составное. Подсчитать число точек кривой на математических пакетах (например, для этого есть open-source пакет SAGE) занимает всего пару строчек кода и секунды машинного времени. Давайте разберемся, в каких конкретно случаях ситуация, когда число точек – составное число, может привести к слабости кривой?           

Сложная задача ECDLP (Elliptic Discrete Curve Logarithm Problem): 
Пусть у нас есть две точки P и Q, которые лежат на кривой одной кривой E: y^2 = x^3 +ax + b mod p
и мы знаем, что они связаны соотношением Q = d*P,( т.е. Q = P + … + P  d раз), которое называется скалярным произведением (или умножение точки на число). 
Задача ECDLP заключается в том, чтобы найти d, зная P и Q.
Скалярное произведение d*P считается быстро даже для больших d. Т.е. зная число d и точку P легко вычислить их произведение – точку Q = d*P. Обратная же задача (т.е. ECDLP) для криптографически сильной кривой обладает экспоненциальной сложностью.   
На практике секретное число d выбирается таким большим, чтобы его было практически невозможно найти, перебирая все его возможные значения и проверяя Q = d*P. 
В нашей конкретной задаче d – это закрытый ключ, Q – открытый ключ, P – генератор подгруппы (или еще одно обозначение - base point). При помощи Base point P любой элемент подгруппы можно представить в виде x*P. 
Итак, решив эту задачу, злоумышленник по известным всем точкам P и Q получит закрытый ключ.  Что это ему даст ? Это зависит от того, в каком протоколе используется ключевая пара открытый-закрытый ключ. В основном на практике эллиптические кривые используются для электронной цифровой подписи, а также в протоколе Диффи-Хеллмана на эллиптических кривых (который используется в протоколе TLS). В первом случае злоумышленник сможет создавать электронную подпись от имени законного владельца пары, во втором случае – вмешиваться в зашифрованный траффик TLS между клиентом и сервером (либо просто расшифровать когда-то записанный).       
Это может произойти, если неправильно подобраны параметры кривой, т.е. кривая криптографически “слабая”. Вообще-то генерацией параметров кривых как правило занимаются профессиональные криптографы, а кривые которые используются в индустрии подробно описаны в различных стандартах и являются объектом многолетних исследований криптографического сообщества. Но мы хотим объяснить, почему кривые, которые используются всеми нами каждый день (например, в браузере при открытии соединения TLS или при подписи блокчейн транзакции) именно такие, а не другие. Постараемся дать вам базовые понятия без использования сложной математики. Это первый шаг к тому, чтобы выяснить, как в эллиптической криптографии все работает “под капотом”. Вполне возможно, что вы когда-нибудь захотите сами сгенерировать эллиптическую кривую для своих систем вместо того, чтобы использовать те, которые вам предлагают в различных стандартах.       
Так в каких же случаях у атакующего есть шанс практически решить задачу ECDLP? Это зависит от порядка точки P, т.е. от минимального числа q, такого, что q*P = O ,  O – это так называемая точка на бесконечности, т.е. точка прибавив к которой любую точку A кривой мы получим снова A:   A + O = A = O + A = A
Пример криптографически “сильной” кривой из реального мира: 
Если порядок точки P (т.е. число элементов подгруппы, которую можно сгенерировать при помощи P) – простое число q, то для решения ECDLP используется алгоритм Полларда (Pollard) (про который мы обязательно расскажем, но позже), которому потребуется приблизительно   операций с точками кривой. Именно этим определяется уровень безопасности кривой.  Пользуясь этой формулой, оценим уровень безопасности кривой secp256k1, которая используется для подписи транзакций в Bitcoin и Ethereum и многих других криптовалютах. Oна имеет следующий вид:  y^2 = x^3 + 7 mod p, где p = 2^256 - 2^32 – 2^9 – 2^8 – 2^6 – 2^4 – 1. Число n всех точек на данной кривой равно 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 Это простое число, следовательно любая точка кривой (кроме точки на бесконечности) имеет порядок n. Кроме того n большее чем 2^255 и меньшее чем 2^256, из чего следует что для решения ECDLP на кривой secp256k1 необходимо выполнить ~ 2^256  ~ 2^128 операций.  Если бы n было равно p + 1 (supersingular curve) или p (anomal curve), то задачу ECDLP можно было бы решить гораздо проще (но про эти случаи мы расскажем вам потом). Поскольку secp256k1 не принадлежит к этим случаям, то можно считать ее практически безопасной. 

Пример криптографически “слабой” кривой (алгоритм Полига-Хеллмана):
А что если порядок n базовой точки – составное число ? К примеру если n = q1*q2*q3, где q1,  q2,  q3 -простые числа, то мы можем задачу нахождения d из соотношения Q = d*P для большой группы размера q1*q2*q3  разбить на три более легкие задачи ECDLP в каждой из подгрупп размера q1, q2, q3 и применить к каждой метод Полларда (Pollard). Выигрыш по сравнению, если бы n было той же длины, но простым числом – очевиден. (поскольку n  больше чем q1 + q2 + q3). Например, в одной из задач хакатона, порядок подгруппы равен 3380401600608612551673141965741   ~ 2^102 т.е. где-то в районе 102 бит. Это число разлагается на три множителя: 3380401600608612551673141965741 = 1696459811*13681084621*145647888811,  самый большой из которых  145647888811 - имеет длину 38 бит. Если мы знаем это число, то это значит, что можно сделать грубую оценку числа шагов для нахождения дискретного логарифма. Оно приблизительно равно числу шагов алгоритма Полларда для самой большой подгруппы. Т.е. в нашем случае это будет ~ 2^38 =  2^19 шагов ( множители 1696459811 (~ 2^31, следовательно необходимо 2^31 шагов для ECDLP в этой подгруппе) и 13681084621 ((~ 2^34) -> 2^34 шагов для ECDLP ) существенно не влияют на общую сумму шагов, поэтому для грубой оценки их можно отбросить). Итак, что мы видим: если бы это была сильная кривая, в подгруппе которой было бы столько же точек, как в рассматриваемой нами слабой, а именно ~ 2^102 точек, то для ее взлома потребовалось бы 2^102  = 2^51 шагов. В нашем же случае слабой кривой мы имеем ~ 2^38 = 2^19 шагов.  Итак, 2^51 и против 2^19. Существенная разница. (Хотя, конечно, 2^51 шагов считается недостаточным уровнем безопасности).              
Итак, есть уравнение Q = d*P в котором Q и P имеют порядок n = q1*q2*q3. Трюк заключается в том, чтобы “перекинуть” (drop or transform (?)) Q и P в маленькие подгруппы и решить в каждой ECDLP.
Начнем с первой подгруппы: 
умножим обе стороны уравнения на q2*q3 :  
(q2*q3)*Q = (q2*q3)*(d*P) 
Очевидно, что 
(q2*q3)*Q = d*((q2*q3)*P)  
(q2*q3)*Q  и  (q2*q3)*P  - точки порядка q1, поэтому решив ECDLP уже для этих точек, можно найти не само d а только остаток, от деления d на q1 :   d1 = d mod q1. 
Для второй подгруппы порядка q2:
точки P и Q умножаем на q1*q3 и получаем точки (q1*q3)*Q  и  (q1*q3)*P, которые имеют порядок q2 
Аналогичным образом решив ECDLP для третьей подгруппы, находим d3 = d mod q3 . 
Поскольку q1, q2, q3 попарно взаимно просты, то мы можем при помощи Китайской Теоремы об Остатках (Chinese Remainder Theorem) восстановить d : 
d = d1*M1*N1 + d2*M2*N2 + d3*M3*N3   mod q1*q1*q3 
где M1 = q2*q3,  а N1 – мультипликативное обратное (multiplicative inverse) к M1 по модулю q1
т.е M1*N1 = 1 mod q1   
Аналогично для остальных Mi и Ni: 
                        M2 = q1*q3,  а N2 обратно к M2 :    M2*N2 = 1 mod q2
                        M3 = q1*q2,  а N3 обратно к M3 :    M3*N3 = 1 mod q3

Итак, мы разобрали, как работает алгоритм Поллига-Хеллмана (Pohlig-Hellman’s algorithm), который предназначен для решения задачи дискретного логарифмирования в группе, в которой содержится составное число элементов. Этот алгоритм можно использовать также и для других циклических групп, а не только для эллиптических кривых. (Например для нахождения дискретного логарифма x в мультипликативной группе:  y = g^x mod p) 
Рассказывая про Pohlig-Hellman’s algorithm, мы предполагали, что у нас был волшебный оракул под названием алгоритм Полларда (Pollard’s algorithm), который решал для нас ECDLP в маленьких подгруппах простого порядка q1, q2, q3. Если какие-либо из них - это действительно небольшие числа, то никакого волшебства не нужно и проще было бы решить ECDLP для таких подгрупп полным перебором (brute-force) всех возможных значений di который потребовал бы порядка qi операций сложения точек. Иначе, если наши вычислительные ресурсы позволяют нам только выполнить только порядка qi операций, но не qi, то нам необходим метод Полларда (Pollard). О нем мы расскажем вам в следующем ролике.           
                        
Дополнение: 
Код на SAGE для решения задачи 
Думаю, что неплохо было бы сделать видео, показывающее, как он работает.   
# Module of curve: 
p = 10141204801825835211973625720983

#coefficients A, B of curve Y^2 = X^3 + A*X + B ( mod p ) 
A = 1
B = 1

E = EllipticCurve(GF(p), [A, B])

#generator of subgroup:  
P = E(5309002981115882633717819748385, 6616280453206239774452958891164)

#Public key: 
Q = E(4433919310871854415036189786662, 9569752741408869820010251554434)


print("Subgroup order:") 

subgroup_order = P.order()

print(factor(subgroup_order))

# we want to find priv such,that  Pub = priv*P   


Q1 = (13681084621*145647888811)*Pub
P1 = (13681084621*145647888811)*P

#print(Pub1.order())
#print(P1.order())

d1 = P1.discrete_log(Pub1)

print(d1)

print(Q1 == d1*P1)

#Pub2 = (1696459811*145647888811)*Pub
#P2 = (1696459811*145647888811)*P

#priv2 = P2.discrete_log(Pub2)

#print(priv2)

#print(Pub2 == priv2*P2)

#Pub3 = (1696459811 * 13681084621)*Pub
#P3 = (1696459811 * 13681084621)*P

#priv3 = P3.discrete_log(Pub3)

#print(priv3)

#print(Pub3 == priv3*P3)


d1 = 1044356496

priv2 = 5112112734

priv3 = 140520355497


q1 = 1696459811 

q2 = 13681084621 

q3 = 145647888811


Priv = priv1*q2*q3*((q2*q3).inverse_mod(q1)) + priv2*q1*q3*((q1*q3).inverse_mod(q2)) + priv3*q1*q2*((q1*q2).inverse_mod(q3))


 

